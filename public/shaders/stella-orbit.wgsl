@group(0)@binding(0)var videoSampler: sampler;@group(0)@binding(2)var videoOUT: texture_2d <f32>;@group(0)@binding(5)var<uniform> iResolution : f32;@group(0)@binding(6)var<uniform> iFrame : f32;@group(0)@binding(7)var<uniform> iTime : f32;var<private> g1 : f32;var<private> g2 : f32;var<private> g3 : f32;var<private> fragColor_1 : vec4<f32>;var<private> gl_FragCoord : vec4<f32>;var<private> iMouse : vec4<f32>;var<private> iPosition : vec4<f32>;fn rot_vf3_vf3_f1_(p_1 : ptr<function, vec3<f32>>, a : ptr<function, vec3<f32>>, t : ptr<function, f32>) {  var u_2 : vec3<f32>;  var v : vec3<f32>;  let x_147 : vec3<f32> = *(a);  *(a) = normalize(x_147);  let x_150 : vec3<f32> = *(a);  let x_151 : vec3<f32> = *(p_1);  u_2 = cross(x_150, x_151);  let x_154 : vec3<f32> = *(a);  let x_155 : vec3<f32> = u_2;  v = cross(x_154, x_155);  let x_157 : vec3<f32> = u_2;  let x_158 : f32 = *(t);  let x_161 : vec3<f32> = v;  let x_162 : f32 = *(t);  let x_166 : vec3<f32> = *(a);  let x_167 : vec3<f32> = *(a);  let x_168 : vec3<f32> = *(p_1);  *(p_1) = (((x_157 * sin(x_158)) + (x_161 * cos(x_162))) + (x_166 * dot(x_167, x_168)));  return;}fn lookAt_vf3_vf3_vf3_vf3_(rd : ptr<function, vec3<f32>>, ro : ptr<function, vec3<f32>>, ta : ptr<function, vec3<f32>>, up : ptr<function, vec3<f32>>) {  var w : vec3<f32>;  var u : vec3<f32>;  let x_101 : vec3<f32> = *(ta);  let x_102 : vec3<f32> = *(ro);  w = normalize((x_101 - x_102));  let x_106 : vec3<f32> = w;  let x_107 : vec3<f32> = *(up);  u = normalize(cross(x_106, x_107));  let x_113 : f32 = (*(rd)).x;  let x_114 : vec3<f32> = u;  let x_118 : f32 = (*(rd)).y;  let x_119 : vec3<f32> = u;  let x_120 : vec3<f32> = w;  let x_126 : f32 = (*(rd)).z;  let x_127 : vec3<f32> = w;  *(rd) = (((x_114 * x_113) + (cross(x_119, x_120) * x_118)) + (x_127 * x_126));  return;}fn sFold45_vf2_(p_3 : ptr<function, vec2<f32>>) {  var v_2 : vec2<f32>;  var g_1 : f32;  v_2 = vec2<f32>(0.70710676908493041992f, -0.70710676908493041992f);  let x_341 : vec2<f32> = *(p_3);  let x_342 : vec2<f32> = v_2;  g_1 = dot(x_341, x_342);  let x_344 : f32 = g_1;  let x_345 : f32 = g_1;  let x_346 : f32 = g_1;  let x_352 : vec2<f32> = v_2;  let x_354 : vec2<f32> = *(p_3);  *(p_3) = (x_354 - (x_352 * (x_344 - sqrt(((x_345 * x_346) + 0.00004999999873689376f)))));  return;}const x_379 = vec3<f32>(0.57735025882720947266f, 0.57735025882720947266f, -0.57735025882720947266f);fn stella_vf3_f1_(p_4 : ptr<function, vec3<f32>>, s_1 : ptr<function, f32>) -> f32 {  var param_4 : vec2<f32>;  var param_5 : vec2<f32>;  let x_356 : vec3<f32> = *(p_4);  let x_357 : vec3<f32> = *(p_4);  *(p_4) = sqrt(((x_356 * x_357) + vec3<f32>(0.00004999999873689376f, 0.00004999999873689376f, 0.00004999999873689376f)));  let x_363 : vec3<f32> = *(p_4);  param_4 = vec2<f32>(x_363.x, x_363.z);  sFold45_vf2_(&(param_4));  let x_366 : vec2<f32> = param_4;  let x_367 : vec3<f32> = *(p_4);  *(p_4) = vec3<f32>(x_366.x, x_367.y, x_366.y);  let x_370 : vec3<f32> = *(p_4);  param_5 = vec2<f32>(x_370.y, x_370.z);  sFold45_vf2_(&(param_5));  let x_373 : vec2<f32> = param_5;  let x_374 : vec3<f32> = *(p_4);  *(p_4) = vec3<f32>(x_374.x, x_373.x, x_373.y);  let x_376 : vec3<f32> = *(p_4);  let x_381 : f32 = *(s_1);  return (dot(x_376, x_379) - x_381);}fn stellas_vf3_(p_5 : ptr<function, vec3<f32>>) -> f32 {  var c : f32;  var e : vec3<f32>;  var param_6 : vec3<f32>;  var param_7 : vec3<f32>;  var param_8 : f32;  var param_9 : vec3<f32>;  var param_10 : f32;  let x_385 : f32 = f32(iTime) ;  let x_388 : f32 = (*(p_5)).y;  (*(p_5)).y = (x_388 - -(x_385));  c = 2.0f;  let x_393 : vec3<f32> = *(p_5);  let x_394 : f32 = c;  e = floor((x_393 / vec3<f32>(x_394, x_394, x_394)));  let x_400 : vec3<f32> = e;  let x_403 : vec3<f32> = e;  e = sin(((((x_400 * 2.5f) + (vec3<f32>(x_403.y, x_403.z, x_403.x) * 3.0f)) + vec3<f32>(1.34500002861022949219f, 1.34500002861022949219f, 1.34500002861022949219f)) * 11.0f));  let x_412 : vec3<f32> = e;  let x_414 : vec3<f32> = *(p_5);  *(p_5) = (x_414 - (x_412 * 0.5f));  let x_416 : vec3<f32> = *(p_5);  let x_417 : f32 = c;  let x_420 : f32 = c;  let x_421 : f32 = (x_420 * 0.5f);  *(p_5) = ((x_416 - (vec3<f32>(x_417, x_417, x_417) * floor((x_416 / vec3<f32>(x_417, x_417, x_417))))) - vec3<f32>(x_421, x_421, x_421));  let x_424 : vec3<f32> = e;  let x_432 : f32 = f32(iTime) ;  let x_435 : vec3<f32> = *(p_5);  param_6 = x_435;  param_7 = (fract(sin((x_424 + vec3<f32>(2060303.5f, 2060303.5f, 2060303.5f)))) - vec3<f32>(0.5f, 0.5f, 0.5f));  param_8 = (x_432 * 1.5f);  rot_vf3_vf3_f1_(&(param_6), &(param_7), &(param_8));  let x_439 : vec3<f32> = param_6;  *(p_5) = x_439;  let x_443 : vec3<f32> = *(p_5);  param_9 = x_443;  param_10 = 0.07999999821186065674f;  let x_445 : f32 = stella_vf3_f1_(&(param_9), &(param_10));  return min(0.69999998807907104492f, x_445);}fn pointAt_vf3_vf3_vf3_(p : ptr<function, vec3<f32>>, dir : ptr<function, vec3<f32>>, up_1 : ptr<function, vec3<f32>>) {  var u_1 : vec3<f32>;  let x_131 : vec3<f32> = *(dir);  let x_132 : vec3<f32> = *(up_1);  u_1 = normalize(cross(x_131, x_132));  let x_135 : vec3<f32> = *(p);  let x_136 : vec3<f32> = u_1;  let x_138 : vec3<f32> = *(p);  let x_139 : vec3<f32> = u_1;  let x_140 : vec3<f32> = *(dir);  let x_143 : vec3<f32> = *(p);  let x_144 : vec3<f32> = *(dir);  *(p) = vec3<f32>(dot(x_135, x_136), dot(x_138, cross(x_139, x_140)), dot(x_143, x_144));  return;}fn pSFold_vf2_f1_(p_2 : ptr<function, vec2<f32>>, n : ptr<function, f32>) {  var h_1 : f32;  var a_2 : f32;  var i : f32;  var v_1 : vec2<f32>;  var g : f32;  let x_173 : f32 = *(n);  h_1 = floor(log2(x_173));  let x_178 : f32 = h_1;  let x_181 : f32 = *(n);  a_2 = ((6.28318548202514648438f * exp2(x_178)) / x_181);  i = 0.0f;  loop {    let x_189 : f32 = i;    let x_190 : f32 = h_1;    if ((x_189 < (x_190 + 2.0f))) {    } else {      break;    }    let x_196 : f32 = a_2;    let x_199 : f32 = a_2;    v_1 = vec2<f32>(-(cos(x_196)), sin(x_199));    let x_203 : vec2<f32> = *(p_2);    let x_204 : vec2<f32> = v_1;    g = dot(x_203, x_204);    let x_206 : f32 = g;    let x_207 : f32 = g;    let x_208 : f32 = g;    let x_214 : vec2<f32> = v_1;    let x_216 : vec2<f32> = *(p_2);    *(p_2) = (x_216 - (x_214 * (x_206 - sqrt(((x_207 * x_208) + 0.00200000009499490261f)))));    let x_219 : f32 = a_2;    a_2 = (x_219 * 0.5f);    continuing {      let x_221 : f32 = i;      i = (x_221 + 1.0f);    }  }  return;}fn structure_vf3_(p_6 : ptr<function, vec3<f32>>) -> f32 {  var d : f32;  var i_2 : i32;  var q : vec3<f32>;  var w_1 : vec3<f32>;  var indexable : array<vec3<f32>, 3u>;  var param_11 : vec3<f32>;  var param_12 : vec3<f32>;  var param_13 : vec3<f32>;  var d0 : f32;  var c_1 : f32;  var e_1 : f32;  var param_14 : vec2<f32>;  var param_15 : f32;  d = 1000.0f;  i_2 = 0i;  loop {    let x_457 : i32 = i_2;    if ((x_457 < 12i)) {    } else {      break;    }    let x_461 : vec3<f32> = *(p_6);    q = x_461;    w_1 = vec3<f32>(0.850650787353515625f, 0.52573108673095703125f, 0.0f);    let x_466 : i32 = i_2;    let x_470 : i32 = i_2;    let x_477 : vec3<f32> = w_1;    let x_479 : vec2<f32> = (vec2<f32>(x_477.x, x_477.y) * ((vec2<f32>(f32(((x_466 >> bitcast<u32>(1i)) & 1i)), f32((x_470 & 1i))) * 2.0f) - vec2<f32>(1.0f, 1.0f)));    let x_480 : vec3<f32> = w_1;    w_1 = vec3<f32>(x_479.x, x_479.y, x_480.z);    let x_482 : vec3<f32> = w_1;    let x_483 : vec3<f32> = w_1;    let x_485 : vec3<f32> = w_1;    let x_490 : i32 = i_2;    indexable = array<vec3<f32>, 3u>(x_482, vec3<f32>(x_483.y, x_483.z, x_483.x), vec3<f32>(x_485.z, x_485.x, x_485.y));    let x_495 : vec3<f32> = indexable[(x_490 % 3i)];    w_1 = x_495;    let x_497 : f32 = w_1.x;    let x_499 : f32 = w_1.y;    let x_502 : f32 = w_1.z;    let x_506 : vec3<f32> = w_1;    let x_509 : vec3<f32> = w_1;    let x_513 : vec3<f32> = q;    param_11 = x_513;    let x_515 : vec3<f32> = w_1;    param_12 = x_515;    param_13 = ((sign(x_502) * -(sign(((x_497 + x_499) + x_502)))) * vec3<f32>(x_509.z, x_509.x, x_509.y));    pointAt_vf3_vf3_vf3_(&(param_11), &(param_12), &(param_13));    let x_518 : vec3<f32> = param_11;    q = x_518;    let x_520 : vec3<f32> = q;    let x_522 : f32 = q.z;    let x_531 : f32 = q.z;    d0 = ((length((x_520 - vec3<f32>(0.0f, 0.0f, clamp(x_522, 2.0f, 8.0f)))) - 0.40000000596046447754f) + (x_531 * 0.05000000074505805969f));    let x_534 : f32 = d;    let x_535 : f32 = d0;    d = min(x_534, x_535);    let x_538 : f32 = d0;    let x_539 : f32 = d0;    let x_543 : f32 = g2;    g2 = (x_543 + (0.10000000149011611938f / (0.10000000149011611938f + (x_538 * x_539))));    c_1 = 0.80000001192092895508f;    let x_549 : f32 = q.z;    let x_550 : f32 = c_1;    let x_552 : f32 = c_1;    e_1 = floor(((x_549 / x_550) - (x_552 * 0.5f)));    let x_556 : f32 = c_1;    let x_558 : f32 = q.z;    let x_559 : f32 = c_1;    let x_566 : f32 = q.z;    q.z = (x_566 - (x_556 * clamp(round((x_558 / x_559)), 3.0f, 9.0f)));    let x_570 : f32 = q.z;    let x_574 : f32 = q.z;    q.z = (x_574 - clamp(x_570, -0.05000000074505805969f, 0.05000000074505805969f));    let x_578 : vec3<f32> = q;    param_14 = vec2<f32>(x_578.x, x_578.y);    param_15 = 5.0f;    pSFold_vf2_f1_(&(param_14), &(param_15));    let x_582 : vec2<f32> = param_14;    let x_583 : vec3<f32> = q;    q = vec3<f32>(x_582.x, x_582.y, x_583.z);    let x_586 : f32 = e_1;    let x_590 : f32 = f32(iTime) ;    let x_593 : f32 = e_1;    let x_595 : i32 = i_2;    let x_602 : f32 = q.y;    q.y = (x_602 - ((1.39999997615814208984f - (x_586 * 0.20000000298023223877f)) + (sin((((x_590 * 10.0f) + x_593) + f32(x_595))) * 0.05000000074505805969f)));    let x_606 : f32 = q.x;    let x_610 : f32 = q.x;    q.x = (x_610 - clamp(x_606, -2.0f, 2.0f));    let x_614 : f32 = q.y;    let x_617 : f32 = q.y;    q.y = (x_617 - clamp(x_614, 0.0f, 0.20000000298023223877f));    let x_620 : vec3<f32> = q;    d0 = ((length(x_620) * 0.69999998807907104492f) - 0.05000000074505805969f);    let x_624 : f32 = d;    let x_625 : f32 = d0;    d = min(x_624, x_625);    let x_627 : f32 = e_1;    let x_628 : f32 = f32(iTime) ;    if ((x_627 == (2.0f + floor(((x_628 * 5.0f) - (7.0f * floor(((x_628 * 5.0f) / 7.0f)))))))) {      let x_637 : f32 = d0;      let x_638 : f32 = d0;      let x_642 : f32 = g1;      g1 = (x_642 + (0.10000000149011611938f / (0.10000000149011611938f + (x_637 * x_638))));    }    continuing {      let x_644 : i32 = i_2;      i_2 = (x_644 + 1i);    }  }  let x_646 : f32 = d;  return x_646;}fn randVec_f1_(s : ptr<function, f32>) -> vec3<f32> {  var n_3 : vec2<f32>;  let x_225 : f32 = *(s);  let x_226 : f32 = *(s);  n_3 = fract(sin((vec2<f32>(x_225, (x_226 + 215.3000030517578125f)) * 12345.5f)));  let x_235 : f32 = n_3.y;  let x_238 : f32 = n_3.x;  let x_242 : f32 = n_3.y;  let x_245 : f32 = n_3.y;  let x_248 : f32 = n_3.x;  return vec3<f32>((cos(x_235) * cos(x_238)), sin(x_242), (cos(x_245) * sin(x_248)));}const x_255 = vec3<f32>(0.0f, 0.0f, 0.0f);fn randCurve_f1_f1_(t_1 : ptr<function, f32>, n_1 : ptr<function, f32>) -> vec3<f32> {  var p_11 : vec3<f32>;  var i_1 : i32;  var param : f32;  p_11 = x_255;  i_1 = 0i;  loop {    let x_265 : i32 = i_1;    if ((x_265 < 3i)) {    } else {      break;    }    let x_269 : f32 = *(n_1);    let x_270 : f32 = (x_269 + 365.0f);    *(n_1) = x_270;    param = x_270;    let x_272 : vec3<f32> = randVec_f1_(&(param));    let x_274 : f32 = *(t_1);    let x_275 : f32 = (x_274 * 1.29999995231628417969f);    *(t_1) = x_275;    let x_276 : f32 = *(t_1);    let x_284 : vec3<f32> = p_11;    p_11 = (x_284 + (x_272 * sin((x_275 + (sin((x_276 * 0.60000002384185791016f)) * 0.5f)))));    continuing {      let x_286 : i32 = i_1;      i_1 = (x_286 + 1i);    }  }  let x_289 : vec3<f32> = p_11;  return x_289;}const x_656 = vec3<f32>(1.0f, 1.0f, 1.0f);fn rabbit_vf3_(p_7 : ptr<function, vec3<f32>>) -> f32 {  var param_16 : f32;  var param_17 : f32;  var param_18 : vec3<f32>;  var param_19 : vec3<f32>;  var param_20 : f32;  var d_1 : f32;  var param_21 : vec3<f32>;  var param_22 : f32;  let x_650 : f32 = f32(iTime) ;  param_16 = x_650;  param_17 = 2576.0f;  let x_652 : vec3<f32> = randCurve_f1_f1_(&(param_16), &(param_17));  let x_654 : vec3<f32> = *(p_7);  *(p_7) = (x_654 - (x_652 * 5.0f));  let x_658 : vec3<f32> = *(p_7);  param_18 = x_658;  param_19 = x_656;  let x_661 : f32 = f32(iTime) ;  param_20 = x_661;  rot_vf3_vf3_f1_(&(param_18), &(param_19), &(param_20));  let x_663 : vec3<f32> = param_18;  *(p_7) = x_663;  let x_666 : vec3<f32> = *(p_7);  param_21 = x_666;  param_22 = 0.20000000298023223877f;  let x_668 : f32 = stella_vf3_f1_(&(param_21), &(param_22));  d_1 = x_668;  let x_669 : f32 = d_1;  let x_670 : f32 = d_1;  let x_674 : f32 = g3;  g3 = (x_674 + (0.10000000149011611938f / (0.10000000149011611938f + (x_669 * x_670))));  let x_676 : f32 = d_1;  return x_676;}fn map_vf3_(p_8 : ptr<function, vec3<f32>>) -> f32 {  var param_23 : vec3<f32>;  var param_24 : vec3<f32>;  var param_25 : vec3<f32>;  let x_680 : vec3<f32> = *(p_8);  param_23 = x_680;  let x_681 : f32 = stellas_vf3_(&(param_23));  let x_683 : vec3<f32> = *(p_8);  param_24 = x_683;  let x_684 : f32 = structure_vf3_(&(param_24));  let x_687 : vec3<f32> = *(p_8);  param_25 = x_687;  let x_688 : f32 = rabbit_vf3_(&(param_25));  return min(min(x_681, x_684), x_688);}fn calcNormal_vf3_(p_9 : ptr<function, vec3<f32>>) -> vec3<f32> {  var n_4 : vec3<f32>;  var i_3 : i32;  var e_2 : vec3<f32>;  var param_26 : vec3<f32>;  n_4 = x_255;  i_3 = 0i;  loop {    let x_699 : i32 = i_3;    if ((x_699 < 4i)) {    } else {      break;    }    let x_705 : i32 = i_3;    let x_709 : i32 = i_3;    let x_713 : i32 = i_3;    e_2 = (((vec3<f32>(f32(((9i >> bitcast<u32>(x_705)) & 1i)), f32(((x_709 >> bitcast<u32>(1i)) & 1i)), f32((x_713 & 1i))) * 2.0f) - vec3<f32>(1.0f, 1.0f, 1.0f)) * 0.00100000004749745131f);    let x_721 : vec3<f32> = e_2;    let x_722 : vec3<f32> = *(p_9);    let x_723 : vec3<f32> = e_2;    param_26 = (x_722 + x_723);    let x_726 : f32 = map_vf3_(&(param_26));    let x_728 : vec3<f32> = n_4;    n_4 = (x_728 + (x_721 * x_726));    continuing {      let x_730 : i32 = i_3;      i_3 = (x_730 + 1i);    }  }  let x_732 : vec3<f32> = n_4;  return normalize(x_732);}fn doColor_vf3_(p_10 : ptr<function, vec3<f32>>) -> vec3<f32> {  var param_27 : vec3<f32>;  let x_737 : vec3<f32> = *(p_10);  param_27 = x_737;  let x_738 : f32 = stellas_vf3_(&(param_27));  if ((x_738 < 0.00100000004749745131f)) {    return vec3<f32>(0.69999998807907104492f, 0.69999998807907104492f, 1.0f);  }  return x_656;}fn orbit_f1_f1_(t_2 : ptr<function, f32>, n_2 : ptr<function, f32>) -> vec3<f32> {  var p_12 : vec3<f32>;  var param_1 : f32;  var param_2 : f32;  var off : vec3<f32>;  var param_3 : f32;  var time : f32;  let x_293 : f32 = *(t_2);  let x_298 : f32 = f32(iTime) ;  param_1 = ((-(x_293) * 1.5f) + x_298);  param_2 = 2576.0f;  let x_303 : vec3<f32> = randCurve_f1_f1_(&(param_1), &(param_2));  p_12 = (x_303 * 5.0f);  let x_308 : f32 = *(n_2);  param_3 = x_308;  let x_309 : vec3<f32> = randVec_f1_(&(param_3));  let x_310 : f32 = *(t_2);  off = ((x_309 * (x_310 + 0.05000000074505805969f)) * 0.60000002384185791016f);  let x_316 : f32 = f32(iTime) ;  let x_317 : f32 = *(n_2);  time = (x_316 + (fract(sin((x_317 * 12345.5f))) * 5.0f));  let x_323 : vec3<f32> = p_12;  let x_324 : vec3<f32> = off;  let x_325 : f32 = time;  let x_326 : f32 = time;  return (x_323 + (x_324 * sin((x_325 + (0.5f * sin((0.5f * x_326)))))));}fn cLine_vf3_vf3_vf3_vf3_(ro_1 : ptr<function, vec3<f32>>, rd_1 : ptr<function, vec3<f32>>, a_1 : ptr<function, vec3<f32>>, b : ptr<function, vec3<f32>>) -> vec3<f32> {  var ab : vec3<f32>;  var ao : vec3<f32>;  var d0_1 : f32;  var d1 : f32;  var d2 : f32;  var t_3 : f32;  var p_13 : vec3<f32>;  let x_762 : vec3<f32> = *(b);  let x_763 : vec3<f32> = *(a_1);  ab = normalize((x_762 - x_763));  let x_767 : vec3<f32> = *(a_1);  let x_768 : vec3<f32> = *(ro_1);  ao = (x_767 - x_768);  let x_771 : vec3<f32> = *(rd_1);  let x_772 : vec3<f32> = ab;  d0_1 = dot(x_771, x_772);  let x_775 : vec3<f32> = *(rd_1);  let x_776 : vec3<f32> = ao;  d1 = dot(x_775, x_776);  let x_779 : vec3<f32> = ab;  let x_780 : vec3<f32> = ao;  d2 = dot(x_779, x_780);  let x_783 : f32 = d0_1;  let x_784 : f32 = d1;  let x_786 : f32 = d2;  let x_788 : f32 = d0_1;  let x_789 : f32 = d0_1;  let x_793 : vec3<f32> = *(b);  let x_794 : vec3<f32> = *(a_1);  t_3 = ((((x_783 * x_784) - x_786) / (1.0f - (x_788 * x_789))) / length((x_793 - x_794)));  let x_798 : f32 = t_3;  t_3 = clamp(x_798, 0.0f, 1.0f);  let x_801 : vec3<f32> = *(a_1);  let x_802 : vec3<f32> = *(b);  let x_803 : vec3<f32> = *(a_1);  let x_805 : f32 = t_3;  let x_808 : vec3<f32> = *(ro_1);  p_13 = ((x_801 + ((x_802 - x_803) * x_805)) - x_808);  let x_810 : vec3<f32> = p_13;  let x_811 : vec3<f32> = *(rd_1);  let x_814 : vec3<f32> = p_13;  let x_815 : vec3<f32> = *(rd_1);  let x_817 : f32 = t_3;  return vec3<f32>(length(cross(x_810, x_811)), dot(x_814, x_815), x_817);}fn hue_f1_(h : ptr<function, f32>) -> vec3<f32> {  let x_749 : f32 = *(h);  return ((cos((((vec3<f32>(0.0f, 0.6666666865348815918f, -0.6666666865348815918f) + vec3<f32>(x_749, x_749, x_749)) * 0.78539818525314331055f) * 8.0f)) * 0.5f) + vec3<f32>(0.5f, 0.5f, 0.5f));}fn mainImage_vf4_vf2_(fragColor : ptr<function, vec4<f32>>, fragCoord : ptr<function, vec2<f32>>) {  var p_14 : vec2<f32>;  var col : vec3<f32>;  var ro_2 : vec3<f32>;  var indexable_1 : array<i32, 4u>;  var param_28 : vec3<f32>;  var param_29 : vec3<f32>;  var param_30 : f32;  var ta_1 : vec3<f32>;  var rd_2 : vec3<f32>;  var param_31 : vec3<f32>;  var param_32 : vec3<f32>;  var param_33 : vec3<f32>;  var param_34 : vec3<f32>;  var z : f32;  var ITR : f32;  var i_4 : f32;  var d_2 : f32;  var param_35 : vec3<f32>;  var p_15 : vec3<f32>;  var nor : vec3<f32>;  var param_36 : vec3<f32>;  var li : vec3<f32>;  var param_37 : vec3<f32>;  var i_5 : f32;  var de : vec3<f32>;  var off_1 : f32;  var j : f32;  var t_4 : f32;  var c_2 : vec3<f32>;  var param_38 : f32;  var param_39 : f32;  var param_40 : f32;  var param_41 : f32;  var param_42 : vec3<f32>;  var param_43 : vec3<f32>;  var param_44 : vec3<f32>;  var param_45 : vec3<f32>;  var s_2 : f32;  var param_46 : f32;  let x_822 : vec2<f32> = *(fragCoord);  let x_826 : vec3<f32> = vec3<f32>(vec3<f32>(iResolution,iResolution,1.0f));  let x_830 : f32 = f32(iResolution);  p_14 = (((x_822 * 2.0f) - vec2<f32>(x_826.x, x_826.y)) / vec2<f32>(x_830, x_830));  col = vec3<f32>(0.0f, 0.0f, 0.05000000074505805969f);  let x_843 : f32 = f32(iTime) ;  let x_846 : f32 = f32(iTime) ;  indexable_1 = array<i32, 4u>(7i, 10i, 12i, 15i);  let x_859 : i32 = indexable_1[(i32(abs((4.0f * sin(((x_843 * 0.30000001192092895508f) + (3.0f * sin((x_846 * 0.20000000298023223877f)))))))) & 3i)];  ro_2 = vec3<f32>(1.0f, 0.0f, f32(x_859));  let x_862 : f32 = f32(iTime) ;  let x_865 : vec3<f32> = ro_2;  param_28 = x_865;  param_29 = x_656;  param_30 = (x_862 * 0.20000000298023223877f);  rot_vf3_vf3_f1_(&(param_28), &(param_29), &(param_30));  let x_869 : vec3<f32> = param_28;  ro_2 = x_869;  ta_1 = vec3<f32>(2.0f, 1.0f, 2.0f);  let x_873 : vec2<f32> = p_14;  rd_2 = normalize(vec3<f32>(x_873.x, x_873.y, 2.0f));  let x_880 : vec3<f32> = rd_2;  param_31 = x_880;  let x_882 : vec3<f32> = ro_2;  param_32 = x_882;  let x_884 : vec3<f32> = ta_1;  param_33 = x_884;  param_34 = vec3<f32>(0.0f, 1.0f, 0.0f);  lookAt_vf3_vf3_vf3_vf3_(&(param_31), &(param_32), &(param_33), &(param_34));  let x_887 : vec3<f32> = param_31;  rd_2 = x_887;  z = 0.0f;  ITR = 50.0f;  i_4 = 0.0f;  loop {    let x_897 : f32 = i_4;    let x_898 : f32 = ITR;    if ((x_897 < x_898)) {    } else {      break;    }    let x_901 : vec3<f32> = ro_2;    let x_902 : vec3<f32> = rd_2;    let x_903 : f32 = z;    param_35 = (x_901 + (x_902 * x_903));    let x_907 : f32 = map_vf3_(&(param_35));    d_2 = x_907;    let x_908 : f32 = z;    z = (x_908 + x_907);    let x_910 : f32 = d_2;    let x_912 : f32 = z;    if (((x_910 < 0.00100000004749745131f) | (x_912 > 30.0f))) {      break;    }    continuing {      let x_919 : f32 = i_4;      i_4 = (x_919 + 1.0f);    }  }  let x_921 : f32 = d_2;  if ((x_921 < 0.00100000004749745131f)) {    let x_926 : vec3<f32> = ro_2;    let x_927 : vec3<f32> = rd_2;    let x_928 : f32 = z;    p_15 = (x_926 + (x_927 * x_928));    let x_933 : vec3<f32> = p_15;    param_36 = x_933;    let x_934 : vec3<f32> = calcNormal_vf3_(&(param_36));    nor = x_934;    li = x_379;    let x_937 : vec3<f32> = p_15;    param_37 = x_937;    let x_938 : vec3<f32> = doColor_vf3_(&(param_37));    col = x_938;    let x_939 : f32 = i_4;    let x_940 : f32 = ITR;    let x_944 : vec3<f32> = col;    col = (x_944 * pow((1.0f - (x_939 / x_940)), 2.0f));    let x_946 : vec3<f32> = nor;    let x_947 : vec3<f32> = li;    let x_950 : vec3<f32> = col;    col = (x_950 * clamp(dot(x_946, x_947), 0.30000001192092895508f, 1.0f));    let x_953 : f32 = nor.y;    let x_957 : vec3<f32> = col;    col = (x_957 * max((0.5f + (0.5f * x_953)), 0.20000000298023223877f));    let x_960 : vec3<f32> = p_15;    let x_961 : vec3<f32> = ro_2;    let x_963 : vec3<f32> = normalize((x_960 - x_961));    let x_964 : vec3<f32> = nor;    let x_971 : vec3<f32> = col;    col = (x_971 + (vec3<f32>(0.80000001192092895508f, 0.10000000149011611938f, 0.0f) * pow(clamp(dot(reflect(x_963, x_964), vec3<f32>(-0.57735025882720947266f, -0.57735025882720947266f, -0.57735025882720947266f)), 0.0f, 1.0f), 30.0f)));    let x_974 : vec3<f32> = p_15;    let x_975 : vec3<f32> = ro_2;    let x_977 : vec3<f32> = normalize((x_974 - x_975));    let x_978 : vec3<f32> = nor;    let x_984 : vec3<f32> = col;    col = (x_984 + (vec3<f32>(0.10000000149011611938f, 0.20000000298023223877f, 0.5f) * pow(clamp(dot(reflect(x_977, x_978), x_379), 0.0f, 1.0f), 30.0f)));    let x_986 : vec3<f32> = col;    let x_987 : f32 = z;    let x_989 : f32 = z;    let x_993 : f32 = exp(((-(x_987) * x_989) * 0.00000999999974737875f));    col = mix(x_255, x_986, vec3<f32>(x_993, x_993, x_993));  }  let x_998 : f32 = g1;  let x_1001 : vec3<f32> = col;  col = (x_1001 + ((vec3<f32>(0.89999997615814208984f, 0.10000000149011611938f, 0.0f) * x_998) * 0.05000000074505805969f));  let x_1004 : f32 = g2;  let x_1007 : vec3<f32> = col;  col = (x_1007 + ((vec3<f32>(0.0f, 0.30000001192092895508f, 0.69999998807907104492f) * x_1004) * 0.07999999821186065674f));  let x_1010 : f32 = g3;  let x_1014 : vec3<f32> = col;  col = (x_1014 + ((vec3<f32>(0.5f, 0.30000001192092895508f, 0.10000000149011611938f) * x_1010) * 0.15000000596046447754f));  ITR = 40.0f;  i_5 = 0.0f;  loop {    var x_1116 : bool;    var x_1117 : bool;    let x_1023 : f32 = i_5;    if ((x_1023 < 1.0f)) {    } else {      break;    }    de = vec3<f32>(1000000000.0f, 1000000000.0f, 1000000000.0f);    let x_1029 : f32 = i_5;    off_1 = fract(sin(((x_1029 * 234.600006103515625f) + 3160448.0f)));    j = 0.0f;    loop {      let x_1042 : f32 = j;      if ((x_1042 < 1.0f)) {      } else {        break;      }      let x_1045 : f32 = j;      let x_1046 : f32 = off_1;      t_4 = (x_1045 + (x_1046 * 0.5f));      let x_1051 : f32 = t_4;      param_38 = x_1051;      let x_1053 : f32 = off_1;      param_39 = x_1053;      let x_1054 : vec3<f32> = orbit_f1_f1_(&(param_38), &(param_39));      let x_1055 : f32 = t_4;      let x_1056 : f32 = ITR;      param_40 = (x_1055 + (1.0f / x_1056));      let x_1061 : f32 = off_1;      param_41 = x_1061;      let x_1062 : vec3<f32> = orbit_f1_f1_(&(param_40), &(param_41));      let x_1064 : vec3<f32> = ro_2;      param_42 = x_1064;      let x_1066 : vec3<f32> = rd_2;      param_43 = x_1066;      param_44 = x_1054;      param_45 = x_1062;      let x_1069 : vec3<f32> = cLine_vf3_vf3_vf3_vf3_(&(param_42), &(param_43), &(param_44), &(param_45));      c_2 = x_1069;      let x_1071 : f32 = de.x;      let x_1073 : f32 = de.x;      let x_1076 : f32 = de.y;      let x_1079 : f32 = c_2.x;      let x_1081 : f32 = c_2.x;      let x_1084 : f32 = c_2.y;      if ((((x_1071 * x_1073) * x_1076) > ((x_1079 * x_1081) * x_1084))) {        let x_1089 : vec3<f32> = c_2;        de = x_1089;        let x_1090 : f32 = j;        let x_1092 : f32 = c_2.z;        let x_1093 : f32 = ITR;        de.z = (x_1090 + (x_1092 / x_1093));      }      continuing {        let x_1097 : f32 = ITR;        let x_1099 : f32 = j;        j = (x_1099 + (1.0f / x_1097));      }    }    let x_1103 : f32 = de.z;    s_2 = (pow(max(0.0f, (0.60000002384185791016f - x_1103)), 2.0f) * 0.10000000149011611938f);    let x_1109 : f32 = de.y;    let x_1110 : bool = (x_1109 > 0.0f);    x_1117 = x_1110;    if (x_1110) {      let x_1113 : f32 = z;      let x_1115 : f32 = de.y;      x_1116 = (x_1113 > x_1115);      x_1117 = x_1116;    }    if (x_1117) {      let x_1121 : f32 = i_5;      param_46 = x_1121;      let x_1122 : vec3<f32> = hue_f1_(&(param_46));      let x_1126 : f32 = de.z;      let x_1130 : f32 = s_2;      let x_1133 : f32 = s_2;      let x_1135 : f32 = de.x;      let x_1139 : vec3<f32> = col;      col = (x_1139 + (((mix(x_656, x_1122, vec3<f32>(0.80000001192092895508f, 0.80000001192092895508f, 0.80000001192092895508f)) * (1.0f - (x_1126 * 0.89999997615814208984f))) * smoothstep((x_1130 + 0.17000000178813934326f), x_1133, x_1135)) * 0.69999998807907104492f));    }    continuing {      let x_1142 : f32 = i_5;      i_5 = (x_1142 + 0.14285714924335479736f);    }  }  let x_1144 : vec3<f32> = col;  let x_1145 : f32 = f32(iTime) ;  let x_1147 : f32 = f32(iTime) ;  let x_1154 : f32 = (0.80000001192092895508f + (0.30000001192092895508f * sin(((x_1145 * 0.5f) + (3.0f * sin((x_1147 * 0.30000001192092895508f)))))));  col = pow(x_1144, vec3<f32>(x_1154, x_1154, x_1154));  let x_1157 : vec3<f32> = col;  let x_1158 : vec4<f32> = *(fragColor);  *(fragColor) = vec4<f32>(x_1157.x, x_1157.y, x_1157.z, x_1158.w);  return;}fn main_1() {  var param_47 : vec4<f32>;  var param_48 : vec2<f32>;  g1 = 0.0f;  g2 = 0.0f;  g3 = 0.0f;  let x_1166 : vec4<f32> = gl_FragCoord;  param_48 = vec2<f32>(x_1166.x, x_1166.y);  mainImage_vf4_vf2_(&(param_47), &(param_48));  let x_1169 : vec4<f32> = param_47;  fragColor_1 = x_1169;  fragColor_1.w = 1.0f;  return;}struct main_out {  @location(0)  fragColor_1_1 : vec4<f32>,  @location(1)  iPosition_1 : vec4<f32>,}@fragment fn main(@builtin(position) gl_FragCoord_param : vec4<f32>) -> main_out {  gl_FragCoord = gl_FragCoord_param;  main_1();  return main_out(fragColor_1, iPosition);}
